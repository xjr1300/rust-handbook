# ボンネットの下（背後）で: `Vec<T>`

<https://marma.dev/articles/2025/under-the-hood-vec-t>

`Vec<T>`の内部の構造をより理解しましょう。

---

Rustの`Vec`の内部構造を探求すると、単純な`ptr`、`len`そして`capacity`フィールドを見つけることを期待できます。
代わりに、一連のネストした型、それぞれの型に追加された生ポインタの最上位の安全性と抽象化のレイヤを明らかにします。
この深い探求は、`Vec`が、安全性、ユーザーとの親和性のあるAPIを構成するために、`NonNull`、`RawVec`そして他のもの（レイヤごとに説明します）のおようなコンポーネントから構築されていることを明らかにします。

## 陰謀だ

[std::vec::Vec](https://doc.rust-lang.org/stable/std/vec/struct.Vec.html)のRust APIドキュメントを読んでいたとき、`Vec`構造体の定義の中に興味深い点に目が止まりました。

```rust
pub struct Vec<T, A = Global>
where
    A: Allocator,
{ /* private fields */ }
```

`{ /* private fields */ }`を見て、「何を隠そうとしているのか？」と私は思いました。
壮大な陰謀に巻き込まれているのだろうか？
ドキュメントは、データ構造の視覚的な表現以外に、これらのフィールドが何であるかについて、ヒントを与えてくれません。

```text
            ptr      len  capacity
       +--------+--------+--------+
       | 0x0123 |      2 |      4 |
       +--------+--------+--------+
            |
            v
Heap   +--------+--------+--------+--------+
       |    'a' |    'b' | uninit | uninit |
       +--------+--------+--------+--------+
```

確かに、`Vec`が`ptr`、`len`そして`capacity`の3つのフィールドを持っていることを見つけました。
しかし、確実に理解するためには、直接情報源に向かう必要があります。
一緒にうさぎの穴に潜り込み、古くからの謎を解明する準備ができたでしょうか？

## `Vec<T>`の多様な側面

`std::vec`にある`Vec`の構造体定義に潜り込むと、次を見つけます。

```rust
pub struct Vec<T, A: Allocator = Global> {
    buf: RawVec<T, A>,
    len: usize,
}
```

> ℹ️ 注記
>
> `Allocator`型を完全に無視します。
> これは、`Allocator`自体で価値のある話題です。

`len`があります！
はい・・・、これは簡単です。
ここでは、`ptr`と`capacity`のみを必要としています。
かなり早く家に帰れそうですか？
いえ、そうでもありません！

この謎めいた`RawVec<T, A>`とは何でしょうか？
当然に自分自身に問いかけ、`ptr`と`capacity`はどこにあるのでしょうか？
では、パンくずを追ってみましょう！

Rust APIドキュメントの検索フィールドに`RawVec`とタイプした場合、何も見つけることができません！？
それを知っていました！
彼らは本当に何かを隠そうとしています！

はい、はい、落ち着いて、ストレスを溜めないでください！
深く息をしてソースコードを確認しましょう。

```rust
pub(crate) struct RawVec<T, A: Allocator = Global> {
    inner: RawVecInner<A>,
    _marker: PhantomData<T>,
}
```

`RasVec`はそのクレートでのみ公開（`pub(crate)`）されており、外部からアクセスできないため、ドキュメント内で見つけることができません。
1つの謎は解けましたが、`RawVecInner<A>`型は一体全体何で、`PhantomData<T>`[^1]とは何なのでしょうか！？
うさぎの穴はどれくらい深いのでしょうか？

`RawVecInner<A>`を確認すると、より明確な姿が見えます。

```rust
struct RawVecInner<A: Allocator = Global> {
    ptr: Unique<u8>,
    cap: Cap,
    alloc: A,
}
```

ハハハ、いいえ、そうでもありません... まあ、少なくともある程度は明確になりました。
ついに見失った`ptr`と`cap(capacity)`を見つけました。
しかし、それら両方は新しい型で定義されています。
現在3層目にいますが、終わりは見えていません。
しかし、ここまで来たから、いまさら止めるわけにはいきませんよね？

> ℹ️ 注記
>
> `Cap`は最小と最大の制限を管理する単なる型であるため、これについては深入りしません。
> しかし、`Cap`を[ここ](https://github.com/rust-lang/rust/blob/2ebb1263e3506412889410b567fa813ca3cb5c63/library/alloc/src/raw_vec/mod.rs#L40)と[ここ](https://github.com/rust-lang/rust/blob/2ebb1263e3506412889410b567fa813ca3cb5c63/library/core/src/num/niche_types.rs#L140)で確認できます。

では、`Unique<u8>`とは何なのでしょうか？

```rust
pub struct Unique<T: PointeeSized> {
    pointer: NonNull<T>,
    _marker: PhantomData<T>,
}
```

ここには何の驚きもなく、単なる他のラッパー型の`NonNull<T>`です。

```rust
pub struct NonNull<T: PointeeSized> {
    pointer: *const T,
}
```

待ってください？！
終わりなのでしょうか？
そう思います！

これで、`Vec`スタック全体の大まかな概要がわかりました。

## `Vec`のレイヤを理解する

旅は次のようなものを確認しました。

- `Vec<T>`が保持しているのは・・・
- `RawVec<T>`が保持しているのは・・・
- `RawVecInner`が保持しているのは・・・
- `Unique<u8>`が保持しているのは・・・
- `NonNull<u8>`が保持しているのは・・・
- `*const u8`（生ポインター）です。

多くの抽象化があります。
しかし、これは何を意味するのでしょうか？
標準ライブラリの背後にいるエンジニアリングチームがこの道を進むことを選択した理由を理解するために、まずそれぞれのレイヤの目的を学ぶ必要があります。
最下層から開始して、`Vec<Mountain>`の最上層にたどり着くまで道を登ります。

## キャンプにて

最下層から開始して、基盤は[*const u8](https://doc.rust-lang.org/std/primitive.pointer.html)で全体の構造を定義した定数のベースキャンプです。

**これはメモリ内の場所を参照する最も原始的な方法**で、生ポインターとも呼ばれています。
`*const u8`は単なるメモリアドレスで数値です。
公式ドキュメントは、`*const u8`が`null`、ダングリング（不正なメモリ領域を指している状態）、または揃っていない（要求される境界に整列していない状態）になる可能性があるため、危険なツールであると記述しています。
`*const u8`はライフタイム情報を持っていないため、コンパイラーはそれが指し示すデータがいつまで有効であるか知ることができません。

`*const u8`を使用することは`unsafe`ブロックで、「私が何をしようとしている理解している」ことをコンパイラーに伝える必要があります。
それは、メモリを管理するために必要なスタート地点で、まずメモリアドレスについて直接話し合えるようにならなければなりません。

> 💡 知っておくと良いこと
>
> [この投稿のRedditのスレッド](https://www.reddit.com/r/rust/comments/1nlw8u0/comment/nf8jobd/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)で、ユーザー（u/Anaxamander57さん）が「なぜポインターが`u8`なのか？」と良い質問をしました。
> Rustのポインターは`usize`に基づいているからです。
>
> その回答は次のとおりです。
> はい、ポインター（アドレス）の値は`usize`に基づいていますが、ポインターはメモリ内の1つのバイト（`u8`）（データの開始地点）を指し示しています。
> 実際、これらは「型を消去」されたバイトです (u/Hy-o-pyeさん、ありがとうございます)。
>
> なぜ、型が消去されているのでしょうか？
> それは、このレベルにおいて、データの型について注意を払うことはできません。
> それは、単なるメモリ内で成長する可能性のあるバッファーに過ぎません。

## ツールを確認するための時間

上昇を安全に続けるための最初のステップは、必要なツールがすべて手元にあることを確認することです。
そこで、工具携帯用ベルトを確認して、それが`NonNull<u8>`であることを確認します。

`NonNull<u8>`は、単純ですが非常に重要なラッパーで、`*const u8`を保護し、**ポインターが決して`null`にならない**という、重要なひとつの保証を提供します。

NULLポインターは、他の言語で数え切れないバグやクラッシュの原因です（それは悪名高い「10億ドルの過ち」です）。
型システムに非NULL保証を直接エンコーディング（実装）することで、Rustはこの種類のエラーを完全に除くことができます。

また、これは素晴らしいコンパイラーの最適化を解放します。
`NonNull<T>`は決して`null`にならないため、コンパイラーは`Option<NonNull<T>>`を扱うとき、`None`バリアントを表現するためにアドレス0を使用できることを理解しています。
これは、`Option<NonNull<T>>`が普通の生ポインターと正確に同じ量の領域を占めることを意味します！
これは安全な抽象化を構築する最初のステップで、コストもゼロです。

## ユニークな道が明らかにする

登りつつケルト、[Unique&lt;u8&gt;](https://github.com/rust-lang/rust/blob/f13ef0d75d834c826c9479a5d244bcfb9891df45/library/core/src/ptr/unique.rs#L7)の道に出会います（少なくとも標識はそのように伝えています・・・）。
それは、非常にスリムなため、とても危険に見えます。
ただ一人だけが、一度にこの道を安全に旅できます。

`Unique<T>`は、生ポインタと、`RawVecInner<A>`のような安全な抽象化との間に位置する、きわめて重要な（内部的な）構成要素です。
`NonNull`を基盤としており、そこに**所有権のシグナル**（単に「所有権」）という非常に強力で欠かせない概念を加えています。

`Unique<T>`は、所有権ルールを強制するガードではありませんが、むしろ`RawVecInner<A>`のような型によって保持され、2つのことをコンパイラーに伝える記号です。

- 「私は、この記号が指し示すデータの単独の所有者です。」
- 「私がスコープを外れたとき、そのデータを**ドロップ**する責任があります。」

ここの興味深いことは、`Unique<T>`ポインターと同じデータを指し示す他の可変参照を作成でき、コンパイラーが不平を言わないことです！

### びっくり！そうですよね？なぜですか？

`Unique<T>`の作成は、単にそれを作成することで、未定義の動作を引き起こさないため安全です。
安全性の境界は、*データをアクセスしている間*など、様々な場所に引かれます。
安全性の懸念は、*ポインターを指し示す値を使用*したいときに発生します。

メモリを読み書きするためにポインターを使用したいとき（`as_mute()`または`as_ref()`で）、`unsafe`ブロックに入らなければなりません。
そして、ここからは、一人ぼっちです。
ワイルドウィストベイビー！

実装者としては次を約束する必要があります。
「私は自分が何をしているか理解しているし、このメモリにアクセスするために他のポインタが使用されていないことを保証します。」

この約束を指示することにより（少しの汗と作業を伴い）、コンパイル時に保証（借用チェックとデータ競合を避ける）を得られます。
これは、Rustのメモリ安全性を可能にするゼロコストの契約です。

## えっと、何かお手伝いしましょうか？

彫刻の後（なぜ登山の途中でこれをするのでしょうか？！）、息切れして、頂上からの助けが必要です。
ロープを下に下ろすために、頂上から優しい人々が最初に尋ねる必要があります。

[RawVec&lt;T&gt;](https://github.com/rust-lang/rust/blob/f13ef0d75d834c826c9479a5d244bcfb9891df45/library/alloc/src/raw_vec/mod.rs#L51)は、「メモリのバッファを管理するための低水準なユーティリティ」です。
それは、割り当て処理と、ヒープ上のメモリブロックの割り当てを尋ねることにより、**メモリアロケーターと実装に話をするコンポーネントです**。
**これはメモリアロケータと直接やり取りするコンポーネント**であり、割り当て処理をしたり、ヒープ上のメモリ領域を確保するようアロケータに要求したり、必要に応じて（通常は容量を2倍にして）その領域を拡張したり、そして何より重要なことに、`Vec`がドロップされたときに確保したメモリを解放します。

すでに学んだ通り、`RawVec<T>`は容量（割り当てられた領域全体）についてのみ理解しています。
`RawVec<T>`は、どれくらいの魚嘘が実際に初期化され、そして使用中なのかを追跡しません。
この意図的な関心の分離により、`RawVec`は完璧に再利用可能な構成要素になります。
標準ライブラリの他のコレクション型は、`VecDeque<T>`のように、メモリで成長するバッファを必要とするため、車輪を再開発する代わりに、このコンポーネントを再利用できます。

> 💡 知っておくことが良いこと
>
> 前に見た`RawVecInner`型を覚えていますか？
> これは賢いコンパイル時の最適化です。
> ロジックを分離することにより、`T`のジェネリックでない部分は、`Vec<T>`を作成するたびに複製されず、コンパイル速度を助けます。
> ロジックを分割することで、`T`に対してジェネリックでない部分（`RawVecInner`）が、作成するすべての `Vec<T>`に対して重複しなくなり、コンパイル速度が向上します。

## 頂上に到達する

ついに、[Vec&lt;Top&gt;](https://github.com/rust-lang/rust/blob/f13ef0d75d834c826c9479a5d244bcfb9891df45/library/alloc/src/vec/mod.rs#L173)に到達して、旗を立てる時間です！

これが、すべてを一緒にまとめるものです。
それは、`RawVec`（メモリを管理する）を保持して、`len`という最後の情報の欠片を追加します。

これはこれまでに学んだ**すべての安全でない複雑さを隠す公開されたAPIとして機能します**。
`Vec`は、割り当てられたブロック（容量）内に、どれだけの要素が初期化されている（`len`）かを知っています。
その責任は、初期化された要素のみにアクセスできるように保証することです。
これは、`push`、`pop`、`insert`、インデックスなど、日々使用するために愛する安全なメソッドを与えてくれます。

それぞれレベルは前のレベルの上に構築され、新しい保証と責任を追加して、完全に安全で効率的かつ強力なデータ構造を実現します。

## 通常の`Vec<Life>`

人生は何事もなく過ぎ去ったようです。
巨大な陰謀もなく、発見された隠された真実もありません。
ただ、非常によいエンジニアリングです。

`Vec<T>`のプライベートフィールドが何であるか学ぶために深堀りしていた間、よいAPI設計というとても興味深いものを明らかにしました。
Rustのエンジニアが、安全でないポインタから始めて、完全に安全で人間工学的になるまで、レイヤーごとに注意深くラップしながら、最も一般的な型のひとつをゼロから構築した方法を確認しました。

それぞれのレイヤは、`Vec`の契約を満たすために非常に重要です。
それは、抽象化と関心の分離の力の証拠です。
「陰謀」は複雑性を扱い、パズルのそれぞれのピースが一つのことをするようにし、それが十分に機能するようにします。
そしてそうすることで、それは標準ライブラリの他のパーツに力を与える再利用可能な型を提供します。

おそらく次の機会に、ベクターに要素を追加するとき、すべてが安全かつ効率的に行われるように、抽象化のスタックがボンネットの下（背後）で機能していることを知るでしょう。
そして、それ自体が、発見されたかなり素晴らしい秘密なのです。

## まとめ

`Vec`の内部構造を明らかにすることは、標準ライブラリ内で背後で起こるものをより少し理解することに役立ちました。

残念ながら、`Vec`を構成する複雑な構造のほんの一部に触れただけです（しかし、より理解するために十分です）。
細部まですべてを説明するのはこの記事では長すぎるので、この記事を読んでいると当然の疑問が発生するため、Rustの内部をより良く説明する「Under the hood」の記事がもっとあるかもしれません。
「`NonNull`がその約束を保証する仕組みは？」または「`RawVec`がメモリを管理する方法は？」など。

この記事で学んだそれぞれの型は、簡潔に触れたもの（`Allocator`、`PhantomData`）を含めて、それ自身の投稿として価値があるため、自分でそれらの型を確認することをおすすめします。
Rustのドキュメントは素晴らしく、
Rustのドキュメントは驚異的で、「定義へ移動」などの最新のIDE機能を使用すると、Rustの公開APIを構成するそれぞれの部分についてより明確な姿が得られるまで簡単に前後に移動できます。

## 脚注

[^1] `PhantomData<T>`の説明は、この記事のスコープ外ですが、他の投稿で確認するかもしれません。
